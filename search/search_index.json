{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Netronome P4 Documentation A compilation of different notes and How tos in operating Netronome SmartNICs with P4. Written by Rui Monteiro and Lu\u00eds Pereira with contributions from Daniel Miranda . Getting Started Virtual Interfaces Migrating from bvm2 Mac Egress CMD Tips and Tricks Replication Useful Assets","title":"Netronome P4 Documentation"},{"location":"#netronome-p4-documentation","text":"A compilation of different notes and How tos in operating Netronome SmartNICs with P4. Written by Rui Monteiro and Lu\u00eds Pereira with contributions from Daniel Miranda . Getting Started Virtual Interfaces Migrating from bvm2 Mac Egress CMD Tips and Tricks Replication Useful Assets","title":"Netronome P4 Documentation"},{"location":"assets/","text":"Assets Development Tools To develop and load programs into the SmartNICs you require at least one of the following tool packages. The Hosted Tool Chain is a set of command line tools to compile and load programs. The SDK is a Graphic IDE with multiple debug capabilities (e.g. Breakpoints). Hosted Tool Chain (Linux) Non Debian systems: Extract the package contents: mkdir tmp dpkg-deb -R nfp-sdk.deb tmp Copy the contents to your opt cp -r tmp/opt/netronome /opt/ Add /opt/netronome/p4/bin to your PATH Test by running: nfp4build SDK This is a Windows program. Either run Windows from a VM or use a compatibility tool (e.g. Bottles ). Documentation After installing at least one of the development tools packages you should have access to all the documentation available: If you installed the Hosted Tool Chain look into /opt/netronome/doc . If you're using the SDK, the documentation is available from within the IDE.","title":"Useful Assets"},{"location":"assets/#assets","text":"","title":"Assets"},{"location":"assets/#development-tools","text":"To develop and load programs into the SmartNICs you require at least one of the following tool packages. The Hosted Tool Chain is a set of command line tools to compile and load programs. The SDK is a Graphic IDE with multiple debug capabilities (e.g. Breakpoints).","title":"Development Tools"},{"location":"assets/#hosted-tool-chain-linux","text":"Non Debian systems: Extract the package contents: mkdir tmp dpkg-deb -R nfp-sdk.deb tmp Copy the contents to your opt cp -r tmp/opt/netronome /opt/ Add /opt/netronome/p4/bin to your PATH Test by running: nfp4build","title":"Hosted Tool Chain (Linux)"},{"location":"assets/#sdk","text":"This is a Windows program. Either run Windows from a VM or use a compatibility tool (e.g. Bottles ).","title":"SDK"},{"location":"assets/#documentation","text":"After installing at least one of the development tools packages you should have access to all the documentation available: If you installed the Hosted Tool Chain look into /opt/netronome/doc . If you're using the SDK, the documentation is available from within the IDE.","title":"Documentation"},{"location":"bmv2/","text":"Migrating from bmv2 This page highlights some differences from the behavioral model (bmv2). Functions/Actions mark_to_drop() does not receive any argument Field Sizes egress_spec is 16 bits long Field Values standard_metadata.instance_type Value Meaning 0x0 Normal 0x1 Clone I2I 0x2 Clone E2I 0x3 Recirculate 0x4 Resubmit 0x8 Clone I2E 0x9 Clone E2E 0xa Multicast User defined metadata User defiened metadata fields are not initialized as 0. isValid method Checking if a header is valid can only be used inside an if clause or in a checksum operation. Using isValid() in an attribution will result in error: identifier \"prdata\" is undefined eg. bit<1> value = (bit<1>)(hdr.hdr.isValid()); In tables valid matching doesn't exist Timestamps Time stamps are 64 bits long Contrary to Bmv2, the ingress_global_timestamp is not available through standard_metadata . If you need to use this field you need to: Declare an intrinsic metadata header: header intrinsic_metadata_t { bit<64> ingress_global_timestamp; } Add it to metadata_t : struct metadata_t { intrinsic_metadata_t intrinsic_metadata; } Known Issues Some issues were encountered with digest messages . In some cases, the message format was not allowed on Netronome, requiring the struct to be changed.","title":"Migrating from bmv2"},{"location":"bmv2/#migrating-from-bmv2","text":"This page highlights some differences from the behavioral model (bmv2).","title":"Migrating from bmv2"},{"location":"bmv2/#functionsactions","text":"mark_to_drop() does not receive any argument","title":"Functions/Actions"},{"location":"bmv2/#field-sizes","text":"egress_spec is 16 bits long","title":"Field Sizes"},{"location":"bmv2/#field-values","text":"standard_metadata.instance_type Value Meaning 0x0 Normal 0x1 Clone I2I 0x2 Clone E2I 0x3 Recirculate 0x4 Resubmit 0x8 Clone I2E 0x9 Clone E2E 0xa Multicast","title":"Field Values"},{"location":"bmv2/#user-defined-metadata","text":"User defiened metadata fields are not initialized as 0.","title":"User defined metadata"},{"location":"bmv2/#isvalid-method","text":"Checking if a header is valid can only be used inside an if clause or in a checksum operation. Using isValid() in an attribution will result in error: identifier \"prdata\" is undefined eg. bit<1> value = (bit<1>)(hdr.hdr.isValid()); In tables valid matching doesn't exist","title":"isValid method"},{"location":"bmv2/#timestamps","text":"Time stamps are 64 bits long Contrary to Bmv2, the ingress_global_timestamp is not available through standard_metadata . If you need to use this field you need to: Declare an intrinsic metadata header: header intrinsic_metadata_t { bit<64> ingress_global_timestamp; } Add it to metadata_t : struct metadata_t { intrinsic_metadata_t intrinsic_metadata; }","title":"Timestamps"},{"location":"bmv2/#known-issues","text":"Some issues were encountered with digest messages . In some cases, the message format was not allowed on Netronome, requiring the struct to be changed.","title":"Known Issues"},{"location":"getting-started/","text":"Getting Started This documentation should provide you with enough insights to understand how to use Netronome SmartNICs with P4 programs. To start a new P4 project, a template is provided and heavily recommended. The rtecli-tui utility is also recommended to more easily interact with each NIC state. Note Before loading programs into a SmartNIC, ensure the target host has the RTE service running.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This documentation should provide you with enough insights to understand how to use Netronome SmartNICs with P4 programs. To start a new P4 project, a template is provided and heavily recommended. The rtecli-tui utility is also recommended to more easily interact with each NIC state. Note Before loading programs into a SmartNIC, ensure the target host has the RTE service running.","title":"Getting Started"},{"location":"mac-cmd/","text":"Mac Egress CMD Due to the internal architecture of the NFP-4000 processors, 4 bytes are required to be prepended on each packet exiting the NIC to pass packet modification instructions directly into the hardware. Important This only applies on physical egress. Which means that if you are relying on this mechanism to compute checksums it will only work for packets leaving the SmartNIC. Altering packets egressing torwards virtual interfaces, will require normal checksum update through P4 control blocks. Usage If you're using the template provided this is already configured. It is recommended to leave it untouched Header declaration: header nfp_mac_eg_cmd_t { bit en_l3_sum; // Enables L3 checksum computation bit en_l4_sum; // Enables L4 checksum computation bit en_ts_mark; // Enables Timestamp marking bit<29> ignore; } Add it to headers struct ( Top position is mandatory! ) struct headers_t { nfp_mac_eg_cmd_t nfp_mac_eg_cmd; // Other headers.... } 3. Add an egress table action add_empty_nfp_mac_eg_cmd() { hdr.nfp_mac_eg_cmd.setValid(); hdr.nfp_mac_eg_cmd = {0, 1, 0, 0x0}; } table table_add_empty_nfp_mac_eg_cmd { key = { standard_metadata.egress_port : exact; } actions = { NoAction; // From core.p4 add_empty_nfp_mac_eg_cmd; } default_action = NoAction; size = 2; } Add the table configuration to the p4cfg file \"egress::table_add_empty_nfp_mac_eg_cmd\": { \"rules\": [ { \"name\": \"p0\", \"match\": { \"standard_metadata.egress_port\": { \"value\": \"p0\" } }, \"action\": { \"type\": \"egress::add_empty_nfp_mac_eg_cmd\" } }, { \"name\": \"p2\", \"match\": { \"standard_metadata.egress_port\": { \"value\": \"p2\" } }, \"action\": { \"type\": \"egress::add_empty_nfp_mac_eg_cmd\" } } ] } Disabling it In theory, it should be possible to disable the usage of this header. This has not been tested yet!!","title":"Mac Egress CMD"},{"location":"mac-cmd/#mac-egress-cmd","text":"Due to the internal architecture of the NFP-4000 processors, 4 bytes are required to be prepended on each packet exiting the NIC to pass packet modification instructions directly into the hardware. Important This only applies on physical egress. Which means that if you are relying on this mechanism to compute checksums it will only work for packets leaving the SmartNIC. Altering packets egressing torwards virtual interfaces, will require normal checksum update through P4 control blocks.","title":"Mac Egress CMD"},{"location":"mac-cmd/#usage","text":"If you're using the template provided this is already configured. It is recommended to leave it untouched Header declaration: header nfp_mac_eg_cmd_t { bit en_l3_sum; // Enables L3 checksum computation bit en_l4_sum; // Enables L4 checksum computation bit en_ts_mark; // Enables Timestamp marking bit<29> ignore; } Add it to headers struct ( Top position is mandatory! ) struct headers_t { nfp_mac_eg_cmd_t nfp_mac_eg_cmd; // Other headers.... } 3. Add an egress table action add_empty_nfp_mac_eg_cmd() { hdr.nfp_mac_eg_cmd.setValid(); hdr.nfp_mac_eg_cmd = {0, 1, 0, 0x0}; } table table_add_empty_nfp_mac_eg_cmd { key = { standard_metadata.egress_port : exact; } actions = { NoAction; // From core.p4 add_empty_nfp_mac_eg_cmd; } default_action = NoAction; size = 2; } Add the table configuration to the p4cfg file \"egress::table_add_empty_nfp_mac_eg_cmd\": { \"rules\": [ { \"name\": \"p0\", \"match\": { \"standard_metadata.egress_port\": { \"value\": \"p0\" } }, \"action\": { \"type\": \"egress::add_empty_nfp_mac_eg_cmd\" } }, { \"name\": \"p2\", \"match\": { \"standard_metadata.egress_port\": { \"value\": \"p2\" } }, \"action\": { \"type\": \"egress::add_empty_nfp_mac_eg_cmd\" } } ] }","title":"Usage"},{"location":"mac-cmd/#disabling-it","text":"In theory, it should be possible to disable the usage of this header. This has not been tested yet!!","title":"Disabling it"},{"location":"replication/","text":"Replication This page presents some useful information about packet replication. General problems in Netronome Warning Keep in mind since the egress_spec is used to keep track of the replication operations, only one of these operations can be used per Ingress|Egress iteration. Multicast Creating multicast groups is very simple, just needing to add \"<GROUP_NAME>\": { \"group_id\": <GROUP_ID>, \"ports\": [ \"v0.0\", \"v0.1\", ... ] } to the multicast section of the p4cfg file. Warning The multicast GROUP_NAME must always start with mg . While the GROUP_ID must be an integer in between 0 and the maximum number of multicast groups. In my personal suggestion, make the GROUP_NAME be mg<GROUP_ID> since this name is merely decorative.","title":"Replication"},{"location":"replication/#replication","text":"This page presents some useful information about packet replication.","title":"Replication"},{"location":"replication/#general-problems-in-netronome","text":"Warning Keep in mind since the egress_spec is used to keep track of the replication operations, only one of these operations can be used per Ingress|Egress iteration.","title":"General problems in Netronome"},{"location":"replication/#multicast","text":"Creating multicast groups is very simple, just needing to add \"<GROUP_NAME>\": { \"group_id\": <GROUP_ID>, \"ports\": [ \"v0.0\", \"v0.1\", ... ] } to the multicast section of the p4cfg file. Warning The multicast GROUP_NAME must always start with mg . While the GROUP_ID must be an integer in between 0 and the maximum number of multicast groups. In my personal suggestion, make the GROUP_NAME be mg<GROUP_ID> since this name is merely decorative.","title":"Multicast"},{"location":"tips/","text":"Tips and Tricks This page presents some useful tips and tricks. It also compiles some scripts to help debugging P4 programs. No action usage Do not use NoAction outside of tables. In Netronome SmartNICs this will cause an error while loading: design_data.c:262 table ingress::tbl_NoAction has no allowed actions . Casting variable to a lower number of bits When casting a variable to a lower number of bits ensure that it won't cause an overflow. This will result in Undefined Behaviour, leading to the machine crashing and possibly the SmartNIC to overheat. Maximum register size The maximum number of values in a register is 2,147,483,647 a.k.a. maximum signed integer value. Validating headers Even though Netronome's Documentation specifies that the validity of a header can be checked in a table using the match type header_valid , this does not appear to work properly. The solution is to use if conditions instead. Using variables/metadata as keys in tables. When converted to micro_c , P4 variables and metadata are stored inside the scalars structure. When referencing these properties in the p4cfg file, they must be addressed in the following manner: scalars.<VariableName> scalars.metadata@<MetadataField> Warning Sometimes the compiler inserts Ingress:: or Egress:: before the scalars.<VariableName> depending if it is used in the Ingress or in the Egress. To check if this prefix is needed you can check the pifs/pif_debug.json and search for Ingress::scalars , if it is defined, then it is the correct one to use. Cloning and Multicasting simultaneously In case you need to multicast a packet and also send it to another interface not on the multicast group, you can not do both simultaneously. As a workaround, first, you need to clone the packet to the Ingress and forward the original one to the inerface outside the multicast group. Then, in the Ingress, check for cloned packets, if true, multicast it. Debugging Locks This script is meant to be used before compiling a program. It will create a new set of registers that reflect the existent locks in the original program. Those registers can later be inspected to help identify acquisitions and releases of locks. import json import sys import os import re if len(sys.argv) !=6: print(\"usage locksRegisterCompiler <.c input file> <.p4cfg input file> <.c output file> <.p4cfg output file> <.p4 file>\") with open(sys.argv[5]) as f: p4FileData = f.read() with open(sys.argv[1]) as f: cFileData = f.read() with open(sys.argv[2]) as f: p4cfgData = json.load(f) for lock,numberOfLocks in re.findall(r\"__declspec\\(emem export aligned\\(64\\)\\) int ([^\\[;\\s]+)(?:\\[(.+)\\])?\\s*;\",cFileData): if numberOfLocks=='': numberOfLocks=1 else: if not numberOfLocks.isnumeric(): r = re.findall(r\"#define\\s+\"+numberOfLocks+r\"\\s+(\\d+)\",cFileData)[0] numberOfLocks=r numberOfLocks=int(numberOfLocks) p4cfgData[\"registers\"][\"configs\"].append( { \"count\": numberOfLocks, \"index\": 0, \"register\": lock, \"name\": lock, \"value\": \"0\" } ) release=lambda x:x.group(0)+(f\"pif_register_{lock}[0].value=0;\" if x.group(1)==None else f\"pif_register_{lock}[{x.group(1)}].value=0;\") acquire=lambda x:x.group(0)+(f\"pif_register_{lock}[0].value=1;\" if x.group(1)==None else f\"pif_register_{lock}[{x.group(1)}].value=1;\") if not re.search(r\"release\\(\\s*\\&\"+lock+r\"(?:\\[(.+)\\])?\\s*\\)\\s*;\"+f\"pif_register_{lock}\"): cFileData = re.sub( r\"release\\(\\s*\\&\"+lock+r\"(?:\\[(.+)\\])?\\s*\\)\\s*;\", release, cFileData) if not re.search(r\"acquire\\(\\s*\\&\"+lock+r\"(?:\\[(.+)\\])?\\s*\\)\\s*;\"+f\"pif_register_{lock}\"): cFileData = re.sub( r\"acquire\\(\\s*\\&\"+lock+r\"(?:\\[(.+)\\])?\\s*\\)\\s*;\", acquire, cFileData) if not re.search(f\"register<bit<1>>({numberOfLocks}) {lock};\"): p4FileData,_ = re.subn( \"#include <v1model.p4>\", f\"#include <v1model.p4>\\nregister<bit<1>>({numberOfLocks}) {lock};\", p4FileData,1 ) with open(sys.argv[3],\"w\") as f: f.write(cFileData) with open(sys.argv[4],\"w\") as f: json.dump(p4cfgData,f,indent=4) with open(sys.argv[5],\"w\") as f: f.write(p4FileData)","title":"Tips and Tricks"},{"location":"tips/#tips-and-tricks","text":"This page presents some useful tips and tricks. It also compiles some scripts to help debugging P4 programs.","title":"Tips and Tricks"},{"location":"tips/#no-action-usage","text":"Do not use NoAction outside of tables. In Netronome SmartNICs this will cause an error while loading: design_data.c:262 table ingress::tbl_NoAction has no allowed actions .","title":"No action usage"},{"location":"tips/#casting-variable-to-a-lower-number-of-bits","text":"When casting a variable to a lower number of bits ensure that it won't cause an overflow. This will result in Undefined Behaviour, leading to the machine crashing and possibly the SmartNIC to overheat.","title":"Casting variable to a lower number of bits"},{"location":"tips/#maximum-register-size","text":"The maximum number of values in a register is 2,147,483,647 a.k.a. maximum signed integer value.","title":"Maximum register size"},{"location":"tips/#validating-headers","text":"Even though Netronome's Documentation specifies that the validity of a header can be checked in a table using the match type header_valid , this does not appear to work properly. The solution is to use if conditions instead.","title":"Validating headers"},{"location":"tips/#using-variablesmetadata-as-keys-in-tables","text":"When converted to micro_c , P4 variables and metadata are stored inside the scalars structure. When referencing these properties in the p4cfg file, they must be addressed in the following manner: scalars.<VariableName> scalars.metadata@<MetadataField> Warning Sometimes the compiler inserts Ingress:: or Egress:: before the scalars.<VariableName> depending if it is used in the Ingress or in the Egress. To check if this prefix is needed you can check the pifs/pif_debug.json and search for Ingress::scalars , if it is defined, then it is the correct one to use.","title":"Using variables/metadata as keys in tables."},{"location":"tips/#cloning-and-multicasting-simultaneously","text":"In case you need to multicast a packet and also send it to another interface not on the multicast group, you can not do both simultaneously. As a workaround, first, you need to clone the packet to the Ingress and forward the original one to the inerface outside the multicast group. Then, in the Ingress, check for cloned packets, if true, multicast it.","title":"Cloning and Multicasting simultaneously"},{"location":"tips/#debugging-locks","text":"This script is meant to be used before compiling a program. It will create a new set of registers that reflect the existent locks in the original program. Those registers can later be inspected to help identify acquisitions and releases of locks. import json import sys import os import re if len(sys.argv) !=6: print(\"usage locksRegisterCompiler <.c input file> <.p4cfg input file> <.c output file> <.p4cfg output file> <.p4 file>\") with open(sys.argv[5]) as f: p4FileData = f.read() with open(sys.argv[1]) as f: cFileData = f.read() with open(sys.argv[2]) as f: p4cfgData = json.load(f) for lock,numberOfLocks in re.findall(r\"__declspec\\(emem export aligned\\(64\\)\\) int ([^\\[;\\s]+)(?:\\[(.+)\\])?\\s*;\",cFileData): if numberOfLocks=='': numberOfLocks=1 else: if not numberOfLocks.isnumeric(): r = re.findall(r\"#define\\s+\"+numberOfLocks+r\"\\s+(\\d+)\",cFileData)[0] numberOfLocks=r numberOfLocks=int(numberOfLocks) p4cfgData[\"registers\"][\"configs\"].append( { \"count\": numberOfLocks, \"index\": 0, \"register\": lock, \"name\": lock, \"value\": \"0\" } ) release=lambda x:x.group(0)+(f\"pif_register_{lock}[0].value=0;\" if x.group(1)==None else f\"pif_register_{lock}[{x.group(1)}].value=0;\") acquire=lambda x:x.group(0)+(f\"pif_register_{lock}[0].value=1;\" if x.group(1)==None else f\"pif_register_{lock}[{x.group(1)}].value=1;\") if not re.search(r\"release\\(\\s*\\&\"+lock+r\"(?:\\[(.+)\\])?\\s*\\)\\s*;\"+f\"pif_register_{lock}\"): cFileData = re.sub( r\"release\\(\\s*\\&\"+lock+r\"(?:\\[(.+)\\])?\\s*\\)\\s*;\", release, cFileData) if not re.search(r\"acquire\\(\\s*\\&\"+lock+r\"(?:\\[(.+)\\])?\\s*\\)\\s*;\"+f\"pif_register_{lock}\"): cFileData = re.sub( r\"acquire\\(\\s*\\&\"+lock+r\"(?:\\[(.+)\\])?\\s*\\)\\s*;\", acquire, cFileData) if not re.search(f\"register<bit<1>>({numberOfLocks}) {lock};\"): p4FileData,_ = re.subn( \"#include <v1model.p4>\", f\"#include <v1model.p4>\\nregister<bit<1>>({numberOfLocks}) {lock};\", p4FileData,1 ) with open(sys.argv[3],\"w\") as f: f.write(cFileData) with open(sys.argv[4],\"w\") as f: json.dump(p4cfgData,f,indent=4) with open(sys.argv[5],\"w\") as f: f.write(p4FileData)","title":"Debugging Locks"},{"location":"vfs/","text":"Virtual Interfaces (VFs) When loading a P4 program, multiple Virtual Interfaces/Functions (VFs) are created (See Changing the number of VFs ). These are usually called vf0_<n> , where n is the index. VFs work just like normal interfaces, and it is possible to assign them IP addresses. In the configuration files, these interfaces are addressed as v0.<n> , while physical interfaces are named p<n> . See config.p4cfg for an example of basic forwarding between virtual and physical interfaces, allowing for external communication. In case of needing to route a packet to a virtual interface without getting its value from the p4cfg file, these values are static and v0.0 corresponds to 0x300 , v0.1 to 0x301 and so on. The same philosophy applies to physical interfaces. p0 corresponds to 0x0 , p1 to 0x1 and so on. Warning When sending network traffic between two or more Netronome SmartNICs keep in mind that VFs with the same name but in different hosts still have the same MAC address! Therefore, you should avoid exchanging traffic between VFs with the same name to avoid routing conflicts. Using the SmartNIC as a router/switch Sometimes it can be useful to send network traffic between local VFs, effectively using the SmartNIC as a router/switch. To do this, you need to utilize Linux namespaces, otherwise traffic is sent through the loopback interface without never touching the NIC. Each namespace will have their own isolated routing tables, this way, by binding one or more VFs to a namespace they become \"isolated\" from the host. To use those interfaces you then need to run the intended programs also from within the namespace. Adding a VF to a namespace Create a namespace ip netns add <name space> Bind a VF to a namespace ip link set <interface> netns <name space> Assign an IP to the interface and set the interface up ip netns exec <name space> ip addr add dev <interface> <ip address> ip netns exec <name space> ip link set dev <interface> up Disable checksum offload for the interface ip netns exec <name space> ethtool --offload <interface> rx off tx off Run a program within a name space ip netns exec <name space> <program> <program args> Example usage The following example demonstrates a simple client <-> server scenario. Note This example assumes you have configured traffic forwarding/routing between vf0_0 and vf0_1 . Create the namespaces ip netns add ns_server ip netns add ns_client Bind an interface to each namespace ip link set vf0_0 netns ns_server ip link set vf0_1 netns ns_client Assign IPs and disable checksums ip netns exec ns_server ip addr add dev vf0_0 10.0.0.1/24 ip netns exec ns_server ip link set dev vf0_0 up ip netns exec ns_server ethtool --offload vf0_0 rx off tx off ip netns exec ns_client ip addr add dev vf0_1 10.0.0.2/24 ip netns exec ns_client ip link set dev vf0_1 up ip netns exec ns_client ethtool --offload vf0_1 rx off tx off Run iperf3 between client and server ip netns exec ns_server iperf3 -s ip netns exec ns_client iperf3 -c 10.0.0.1 Important Depending on your test configuration, type of traffic, number of VFs in each namespace, etc... You may be required to configure routing/forwarding rules inside each namespace using ip netns exec <namespace> . Changing the number of VFs By default, 4 VFs are created when a P4 program is loaded. A single NIC supports up to 64 different VFs. To change the number of VFs, edit the value of NUM_VFS at /usr/lib/systemd/system/nfp-sdk6-rte.service : Example: Environment=NUM_VFS=10 After applying the changes restart the RTE service.","title":"Virtual Interfaces"},{"location":"vfs/#virtual-interfaces-vfs","text":"When loading a P4 program, multiple Virtual Interfaces/Functions (VFs) are created (See Changing the number of VFs ). These are usually called vf0_<n> , where n is the index. VFs work just like normal interfaces, and it is possible to assign them IP addresses. In the configuration files, these interfaces are addressed as v0.<n> , while physical interfaces are named p<n> . See config.p4cfg for an example of basic forwarding between virtual and physical interfaces, allowing for external communication. In case of needing to route a packet to a virtual interface without getting its value from the p4cfg file, these values are static and v0.0 corresponds to 0x300 , v0.1 to 0x301 and so on. The same philosophy applies to physical interfaces. p0 corresponds to 0x0 , p1 to 0x1 and so on. Warning When sending network traffic between two or more Netronome SmartNICs keep in mind that VFs with the same name but in different hosts still have the same MAC address! Therefore, you should avoid exchanging traffic between VFs with the same name to avoid routing conflicts.","title":"Virtual Interfaces (VFs)"},{"location":"vfs/#using-the-smartnic-as-a-routerswitch","text":"Sometimes it can be useful to send network traffic between local VFs, effectively using the SmartNIC as a router/switch. To do this, you need to utilize Linux namespaces, otherwise traffic is sent through the loopback interface without never touching the NIC. Each namespace will have their own isolated routing tables, this way, by binding one or more VFs to a namespace they become \"isolated\" from the host. To use those interfaces you then need to run the intended programs also from within the namespace.","title":"Using the SmartNIC as a router/switch"},{"location":"vfs/#adding-a-vf-to-a-namespace","text":"Create a namespace ip netns add <name space> Bind a VF to a namespace ip link set <interface> netns <name space> Assign an IP to the interface and set the interface up ip netns exec <name space> ip addr add dev <interface> <ip address> ip netns exec <name space> ip link set dev <interface> up Disable checksum offload for the interface ip netns exec <name space> ethtool --offload <interface> rx off tx off Run a program within a name space ip netns exec <name space> <program> <program args>","title":"Adding a VF to a namespace"},{"location":"vfs/#example-usage","text":"The following example demonstrates a simple client <-> server scenario. Note This example assumes you have configured traffic forwarding/routing between vf0_0 and vf0_1 . Create the namespaces ip netns add ns_server ip netns add ns_client Bind an interface to each namespace ip link set vf0_0 netns ns_server ip link set vf0_1 netns ns_client Assign IPs and disable checksums ip netns exec ns_server ip addr add dev vf0_0 10.0.0.1/24 ip netns exec ns_server ip link set dev vf0_0 up ip netns exec ns_server ethtool --offload vf0_0 rx off tx off ip netns exec ns_client ip addr add dev vf0_1 10.0.0.2/24 ip netns exec ns_client ip link set dev vf0_1 up ip netns exec ns_client ethtool --offload vf0_1 rx off tx off Run iperf3 between client and server ip netns exec ns_server iperf3 -s ip netns exec ns_client iperf3 -c 10.0.0.1 Important Depending on your test configuration, type of traffic, number of VFs in each namespace, etc... You may be required to configure routing/forwarding rules inside each namespace using ip netns exec <namespace> .","title":"Example usage"},{"location":"vfs/#changing-the-number-of-vfs","text":"By default, 4 VFs are created when a P4 program is loaded. A single NIC supports up to 64 different VFs. To change the number of VFs, edit the value of NUM_VFS at /usr/lib/systemd/system/nfp-sdk6-rte.service : Example: Environment=NUM_VFS=10 After applying the changes restart the RTE service.","title":"Changing the number of VFs"}]}